CREATE TABLE address (
  id SERIAL PRIMARY KEY,
  number VARCHAR(10) NOT NULL,
  street VARCHAR(100) NOT NULL,
  city VARCHAR(50) NOT NULL,
  state VARCHAR(30) NOT NULL,
  cep VARCHAR(10) NOT NULL,
  country VARCHAR(50) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE library (
  id SERIAL PRIMARY KEY,
  address_id INTEGER NOT NULL REFERENCES address(id) ON DELETE RESTRICT,
  fantasy_name VARCHAR(100) NOT NULL,
  cnpj VARCHAR(20) UNIQUE NOT NULL,
  phone VARCHAR(20) NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Tabela para armazenar informações dos livros (títulos)
CREATE TABLE book (
  id SERIAL PRIMARY KEY,
  isbn VARCHAR(20) UNIQUE NOT NULL,
  title VARCHAR(200) NOT NULL,
  publisher VARCHAR(100) NOT NULL,
  edition VARCHAR(20) NOT NULL,
  release_date DATE,
  language VARCHAR(30) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Tabela para controlar os exemplares físicos de cada livro
CREATE TABLE book_copy (
  id SERIAL PRIMARY KEY,
  book_id INTEGER NOT NULL REFERENCES book(id) ON DELETE CASCADE,  
  library_id INTEGER NOT NULL REFERENCES library(id) ON DELETE CASCADE,
  acquisition_date DATE NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'available' CHECK (status IN ('available', 'loaned', 'maintenance', 'lost')),
  location VARCHAR(50), -- localização física na biblioteca
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE author (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  birth_date DATE,
  nationality VARCHAR(50),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE book_author (
  id SERIAL PRIMARY KEY,
  author_id INTEGER NOT NULL REFERENCES author(id) ON DELETE CASCADE,
  book_id INTEGER NOT NULL REFERENCES book(id) ON DELETE CASCADE,
  UNIQUE (author_id, book_id)
);

CREATE TABLE category (
  id SERIAL PRIMARY KEY,
  category VARCHAR(50) NOT NULL UNIQUE,
  description TEXT
);

CREATE TABLE book_category (
  id SERIAL PRIMARY KEY,
  book_id INTEGER NOT NULL REFERENCES book(id) ON DELETE CASCADE,
  category_id INTEGER NOT NULL REFERENCES category(id) ON DELETE RESTRICT,
  UNIQUE (book_id, category_id)
);

CREATE TABLE employee (
  id SERIAL PRIMARY KEY,
  address_id INTEGER NOT NULL REFERENCES address(id) ON DELETE RESTRICT,
  library_id INTEGER NOT NULL REFERENCES library(id) ON DELETE RESTRICT,
  name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  date_of_birth DATE NOT NULL,
  cpf VARCHAR(14) UNIQUE NOT NULL,
  registration VARCHAR(20) UNIQUE NOT NULL,
  phone VARCHAR(20) NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  date_of_admission DATE NOT NULL,
  position VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'on_leave')),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE customer (
  id SERIAL PRIMARY KEY,
  address_id INTEGER NOT NULL REFERENCES address(id) ON DELETE RESTRICT,
  name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  date_of_birth DATE NOT NULL,
  cpf VARCHAR(14) UNIQUE NOT NULL,
  phone VARCHAR(20) NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'blocked', 'inactive')),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE loan (
  id SERIAL PRIMARY KEY,
  employee_id INTEGER NOT NULL REFERENCES employee(id) ON DELETE RESTRICT,
  customer_id INTEGER NOT NULL REFERENCES customer(id) ON DELETE RESTRICT,
  loan_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  due_date TIMESTAMP NOT NULL,
  return_date TIMESTAMP,
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'returned', 'late', 'lost')),
  late_fine NUMERIC(10,2) DEFAULT 0.00,
  notes TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE loan_item (
  id SERIAL PRIMARY KEY,
  book_copy_id INTEGER NOT NULL REFERENCES book_copy(id) ON DELETE RESTRICT,
  loan_id INTEGER NOT NULL REFERENCES loan(id) ON DELETE CASCADE,
  return_condition VARCHAR(50),
  UNIQUE (book_copy_id, loan_id)
);

-- Índices para melhorar performance
CREATE INDEX idx_book_title ON book(title);
CREATE INDEX idx_author_name ON author(name, last_name);
CREATE INDEX idx_loan_status ON loan(status);
CREATE INDEX idx_book_copy_status ON book_copy(status);
CREATE INDEX idx_customer_name ON customer(name, last_name);

-- Trigger para atualizar updated_at automaticamente
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = now(); 
   RETURN NEW;
END;
$$ language 'plpgsql';

-- Exemplo de aplicação do trigger (repita para outras tabelas)
CREATE TRIGGER update_customer_modtime
BEFORE UPDATE ON customer
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
